exit
all_days.uniq
all_days
@next_day
exit
DateTime.parse(row[:start]).strftime("%m/%d")
DateTime.parse(row[:start].strftime("%m/%d"))
require 'date'
DateTime.parse(row[:start].strftime("%m/%d"))
DateTime.parse(row[:start].strftime("%m/%d")
exit
   15:                   track_id: track.id,
   14:                   name: row[:name],
   13:                   end_time: DateTime.parse(row[:finish]),
Event.create(start_time: DateTime.parse(row[:start]),
day
dat
exit
@events.last.start_time.strftime("%m/%d")
@events.last.strftime("%m/%d")
@events.last.strftime(%m/%d)
@events.last
first_day
@events = Event.all { |event| day_of_event(event) == first_day }
"%d")
exit
@events
whereami
exit
Event.all.each { |e| e.track.name }
Event.all.each { |e| e.track }
Event.all.each do |e|
Event.all
Event.all.each do |e|
Event.first.track.name
Event.first.track
@events
exit
Track.last
event_hash
exit
event_hash.first[:start]
event_hash.first[start]
event_hash.first.start
event_hash
exit
csv.to_a.map { |row| row.to_hash }
csv = CSV.open("data/test_events.csv", :headers => true, :header_converters => :symbol, :converters => :all)
csv.first
csv = CSV.new("data/test_events.csv", :headers => true, :header_converters => :symbol, :converters => :all)
csv.first
csv = CSV.open("data/test_events.csv", :headers => true, :header_converters => :symbol, :converters => :all)
csv = CSV.open("../data/test_events.csv", :headers => true, :header_converters => :symbol, :converters => :all)
csv = CSV.open("../../data/test_events.csv", :headers => true, :header_converters => :symbol, :converters => :all)
csv = CSV.opem("../../data/test_events.csv", :headers => true, :header_converters => :symbol, :converters => :all)
csv.to_a.map { |row| row.to_hash }
csv = CSV.new("../../data/test_events.csv", :headers => true, :header_converters => :symbol, :converters => :all)
csv = CSV.new("../data/test_events.csv", :headers => true, :header_converters => :symbol, :converters => :all)
csv.to_a.map { |row| row.to_hash }
csv
